{"data":{"projects":[{"artistName":"DCA","description":"Genesis: Generative System. A block hash string is interpreted into a visual composition using a set of algorithmic rules. Compositions may contain grids, gradients, lines, shapes, and colors that harmonize with each other. Each mint is one of a kind and designed to stand-alone. Limited Edition.","maxInvocations":"512","name":"Genesis","projectId":"1","script":"tokenData = tokenData.hashes[0].substring(2);\nint[] hp = new int[32];\n\nvoid setup() {\n\tsize(window.innerWidth>window.innerHeight*4/3?window.innerHeight*4/3:window.innerWidth, window.innerWidth>window.innerHeight*4/3?window.innerHeight:window.innerWidth*3/4);\n\tfor (int i = 0; i < 32; i = i + 1) {\n\t\thp[i] = unhex(tokenData.substring(i + i, i + i + 2));\n\t}\n\tbackground(hp[0], hp[1], hp[2], A(hp[3]));\n}\n\nint B(int _num){\n\treturn (int) map(_num, 0, 255, 100, 255);\n}\n\nint C(int _num) {\n\treturn (int) map(_num, 0, 255, 0, 255);\n}\n\nint A(int _num) {\n\treturn (int) map(_num, 0, 255, 50, 100);\n}\n\nint G(_num) {\n\treturn (int) map(_num, 0, 255, 100, 200);\n}\n\nint X(int _num) {\n\tfloat padding = width * 0.2;\n\treturn (int) map(_num, 0, 255, padding, width - padding);\n}\nint Y(int _num) {\n\tfloat padding = height * 0.2;\n\treturn (int) map(_num, 0, 255, padding, height - padding);\n}\nint R(int _num) {\n\treturn (int) map(_num, 0, 255, 0, 32);\n}\n\nvoid draw() {\n\tnoLoop();\n\tbackground(B(hp[28]),B(hp[29]),B(hp[30]));\n\tGrid grid = new Grid(R(hp[0]), R(hp[1]));\n\tif (hp[2] > 150) {\n\t\tgrid.show_diagonal(hp[3]);\n\t\tgrid.show_diagonal(-hp[4]);\n\t} else if (hp[2] > 85) {\n\t\tgrid.show_horizontal();\n\t\tgrid.show_vertical();\n\t}\n\n\tRectangle rectangle1 = new Rectangle(X(hp[5]), Y(hp[6]), R(hp[7]));\n\tif (hp[8] > 0 && hp[8] < 85) {\n\t\trectangle1.show5(C(hp[9]), C(hp[10]), C(hp[11]), A(hp[12]));\n\t} else if (hp[8] > 84 && hp[8] < 170) {\n\t\trectangle1.show3(C(hp[9]), C(hp[10]), C(hp[11]), A(hp[12]));\n\t} else {\n\t\trectangle1.show1(C(hp[9]), C(hp[10]), C(hp[11]), A(hp[12]));\n\t}\n\n\tLineMaker lines = new LineMaker(hp);\n\tif (R(hp[14]) == 10) {\n\t\tlines.show_points(4);\n\t\tlines.compute_distance(100);\n\t} else if (R(hp[14]) == 11) {\n\t\tlines.show_points(4);\n\t} else if (R(hp[14]) == 12) {\n\t\tlines.show_scribble();\n\t} else if (R(hp[14]) == 13) {\n\t\tlines.show_lines(R(hp[13]));\n\t} else if (R(hp[14]) == 14) {\n\t\tlines.show_complex_lines(R(hp[15]));\n\t} else if (R(hp[14]) == 15) {\n\t\tlines.show_stars(R(hp[15]));\n\t} else if (R(hp[14]) == 16) {\n\t\tlines.show_points(15);\n\t\tlines.show_points(10);\n\t\tlines.show_points(5);\n\t} else if (R(hp[14]) == 17) {\n\t\tlines.show_points(R(hp[16]));\n\t} else if (R(hp[14]) == 18) {\n\t\tlines.show_dots();\n\t} else if (R(hp[14]) == 19) {\n\t\tlines.draw_bezier_disjoint();\n\t} else if (R(hp[14]) == 20) {\n\t\tlines.show_points(5);\n\t\tlines.show_lines(R(hp[13]));\n\t\tlines.show_dots();\n\t\tlines.show_stars(R(hp[0]));\n\t\tlines.show_complex_lines(R(hp[15]));\n\t} else if (R(hp[14]) == 21) {\n\t\tlines.compute_distance(100);\n\t} else if (R(hp[14]) > 21 && R(hp[14]) < 28) {\n\t\tlines.show_stars(R(hp[1]));\n\t}\n\n\tRectangle rectangle2 = new Rectangle(X(hp[18]), Y(hp[19]), R(hp[21]));\n\tif (hp[20] > 0 && hp[20] < 85) {\n\t\trectangle2.show5(C(hp[22]), C(hp[23]), C(hp[24]), A(hp[25]));\n\t} else if (hp[20] > 84 && hp[20] < 170) {\n\t\trectangle2.show3(C(hp[22]), C(hp[23]), C(hp[24]), A(hp[25]));\n\t} else {\n\t\trectangle2.show1(C(hp[22]), C(hp[23]), C(hp[24]), A(hp[25]));\n\t}\n\n\tTrapezoid trap1 = new Trapezoid(X(hp[27]), Y(hp[28]), X(hp[29]), Y(hp[30]), X(hp[31]), Y(hp[0]), X(hp[1]), Y(hp[2]));\n\tif (hp[26] > 210) {\n\t\ttrap1.show_lines(0, 0, 0, 255);\n\t} else if (hp[26] > 168) {\n\t\ttrap1.show_lines(C(hp[3]), C(hp[4]), C(hp[5]), A(hp[6]));\n\t} else if (hp[26] > 126) {\n\t\ttrap1.show_shapes(C(hp[3]), C(hp[4]), C(hp[5]), A(hp[6]));\n\t} else if (hp[26] > 84) {\n\t\ttrap1.show_lines(C(hp[3]), C(hp[4]), C(hp[5]), 255);\n\t} else if (hp[26] > 42) {\n\t\tlines.draw_bezier();\n\t} else {\n\t\ttrap1.show_lines(255, 255, 255, 255);\n\t}\n\tTrapezoid trap2 = new Trapezoid(X(hp[7]), Y(hp[8]), X(hp[9]), Y(hp[10]), X(hp[11]), Y(hp[12]), X(hp[13]), Y(hp[14]));\n\ttrap2.show_shapes(C(hp[15]), C(hp[16]), C(hp[17]), A(hp[18]));\n}\nclass LineMaker {\n\tPVector[] points_array;\n\tLineMaker(int[] _hp) {\n\t\tpoints_array = new PVector[_hp.length()];\n\t\tfor (int i = 0; i < _hp.length(); i++) {\n\t\t\tif (i == _hp.length - 1) {\n\t\t\t\tpoints_array[i] = new PVector(X(_hp[i]), Y(_hp[0]));\n\t\t\t} else {\n\t\t\t\tpoints_array[i] = new PVector(X(_hp[i]), Y(_hp[i + 1]));\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid show_points(int size) {\n\t\tcolor fill1 = color(255, 255, 255, 50);\n\t\tfill(fill1);\n\t\tnoStroke();\n\t\tfor (int i = 0; i < points_array.length; i++) {\n\t\t\tellipse(points_array[i].x, points_array[i].y, size, size);\n\t\t}\n\t}\n\n\tvoid compute_distance(int max_distance) {\n\t\tfor (int i = 0; i < points_array.length; i++) {\n\t\t\tfor (int j = 0; j < points_array.length; j++) {\n\t\t\t\tif (dist(points_array[i].x, points_array[i].y, points_array[j].x, points_array[j].y) < max_distance) {\n\t\t\t\t\tif (dist(points_array[i].x, points_array[i].y, points_array[j].x, points_array[j].y) != 0) {\n\t\t\t\t\t\tif ((points_array[i].x != points_array[j].x) && (points_array[i].y != points_array[j].y)) {\n\t\t\t\t\t\t\tstrokeWeight(1);\n\t\t\t\t\t\t\tstroke(0, 0, 0, 255);\n\t\t\t\t\t\t\tline(points_array[i].x, points_array[i].y, points_array[j].x, points_array[j].y);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid show_scribble() {\n\t\tnoFill();\n\t\tstrokeWeight(1);\n\t\tstroke(255, 255, 255, 75);\n\t\tfor (int i = 0; i < points_array.length; i++) {\n\t\t\tif (i < points_array.length - 1) {\n\t\t\t\tline(points_array[i].x, points_array[i].y, points_array[i + 1].x, points_array[i + 1].y);\n\t\t\t} else {\n\t\t\t\tline(points_array[i].x, points_array[i].y, points_array[0].x, points_array[0].y);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid show_lines(int divider) {\n\t\tnoFill();\n\t\tstrokeWeight(1);\n\t\tstroke(255, 255, 255, 75);\n\t\tfor (int i = 0; i < points_array.length; i++) {\n\t\t\tif (i % divider == 0) {\n\t\t\t\tif (i < points_array.length - 1) {\n\t\t\t\t\tline(points_array[i].x, points_array[i].y, points_array[i + 1].x, points_array[i + 1].y);\n\t\t\t\t} else {\n\t\t\t\t\tline(points_array[i].x, points_array[i].y, points_array[0].x, points_array[0].y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid show_complex_lines(int divider) {\n\t\tnoFill();\n\t\tstrokeWeight(1);\n\t\tstroke(0, 0, 0, 150);\n\t\tfor (int i = 0; i < points_array.length; i++) {\n\t\t\tif (i % divider == 0) {\n\t\t\t\tif (i < points_array.length - 3) {\n\t\t\t\t\tline(points_array[i].x, points_array[i].y, points_array[i + 1].x, points_array[i + 1].y);\n\t\t\t\t\tline(points_array[i + 1].x, points_array[i + 1].y, points_array[i + 2].x, points_array[i + 2].y);\n\t\t\t\t\tline(points_array[i + 2].x, points_array[i + 2].y, points_array[i + 3].x, points_array[i + 3].y);\n\t\t\t\t} else {\n\t\t\t\t\tline(points_array[i].x, points_array[i].y, points_array[0].x, points_array[0].y);\n\t\t\t\t\tline(points_array[0].x, points_array[0].y, points_array[1].x, points_array[1].y);\n\t\t\t\t\tline(points_array[1].x, points_array[1].y, points_array[2].x, points_array[2].y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid draw_bezier() {\n\t\tnoFill();\n\t\tstrokeWeight(width * 0.0015);\n\t\tstroke(255, 255, 255, 255);\n\t\tbezier(points_array[12].x, points_array[12].y, points_array[1].x, points_array[1].y, points_array[2].x, points_array[2].y, points_array[3].x, points_array[3].y);\n\t\tbezier(points_array[3].x, points_array[3].y, points_array[16].x, points_array[16].y, points_array[17].x, points_array[17].y, points_array[18].x, points_array[18].y);\n\t\tbezier(points_array[18].x, points_array[18].y, points_array[26].x, points_array[26].y, points_array[27].x, points_array[27].y, points_array[12].x, points_array[12].y);\n\t}\n\n\tvoid draw_bezier_disjoint() {\n\t\tnoFill();\n\t\tstrokeWeight(width * 0.0015);\n\t\tstroke(255, 255, 255, 255);\n\t\tbezier(points_array[12].x, points_array[12].y, points_array[1].x, points_array[1].y, points_array[2].x, points_array[2].y, points_array[3].x, points_array[3].y);\n\t\tbezier(points_array[5].x, points_array[5].y, points_array[16].x, points_array[16].y, points_array[17].x, points_array[17].y, points_array[18].x, points_array[18].y);\n\t\tbezier(points_array[20].x, points_array[20].y, points_array[26].x, points_array[26].y, points_array[27].x, points_array[27].y, points_array[12].x, points_array[12].y);\n\t\tstrokeWeight(width * 0.0090);\n\t\tstroke(255, 255, 255, 90);\n\t\tbezier(points_array[12].x, points_array[12].y, points_array[1].x, points_array[1].y, points_array[2].x, points_array[2].y, points_array[3].x, points_array[3].y);\n\t\tbezier(points_array[3].x, points_array[3].y, points_array[16].x, points_array[16].y, points_array[17].x, points_array[17].y, points_array[18].x, points_array[18].y);\n\t\tbezier(points_array[18].x, points_array[18].y, points_array[26].x, points_array[26].y, points_array[27].x, points_array[27].y, points_array[12].x, points_array[12].y);\n\t\tstrokeWeight(width * 0.0145);\n\t\tstroke(255, 255, 255, 30);\n\t\tbezier(points_array[12].x, points_array[12].y, points_array[1].x, points_array[1].y, points_array[2].x, points_array[2].y, points_array[3].x, points_array[3].y);\n\t\tbezier(points_array[4].x, points_array[4].y, points_array[16].x, points_array[16].y, points_array[17].x, points_array[17].y, points_array[18].x, points_array[18].y);\n\t\tbezier(points_array[19].x, points_array[19].y, points_array[26].x, points_array[26].y, points_array[27].x, points_array[27].y, points_array[12].x, points_array[12].y);\n\t}\n\n\tvoid show_dots() {\n\t\tnoStroke();\n\t\tpushMatrix();\n\t\tfor (int i = 0; i < 32; i++) {\n\t\t\tfill(199 * i % 255, 35 * i % 255, 240 * i % 255, 100);\n\t\t\tellipse(points_array[i].x, points_array[i].y, 20, 20);\n\t\t\ttranslate(width / 2, height / 2);\n\t\t\trotate(PI / 4);\n\t\t\ttranslate(-width / 2, -height / 2);\n\t\t}\n\t\tpopMatrix();\n\t}\n\n\tvoid show_stars(int line_count) {\n\t\tstrokeWeight(width * 0.0015);\n\t\tnoStroke();\n\t\tpushMatrix();\n\t\tfor (int i = 0; i < line_count; i++) {\n\t\t\tif (i == line_count - 1) {\n\t\t\t\tstroke((199 * i + 10) % 255, (35 * i + 10) % 255, (240 * i + 10) % 255, 100);\n\t\t\t\tline(points_array[i].x, points_array[i].y, points_array[0].x/3, points_array[0].y/3);\n\t\t\t\ttranslate(width / 2, height / 2);\n\t\t\t\trotate(PI / 7);\n\t\t\t\ttranslate(-width / 2, -height / 2);\n\t\t\t} else {\n\t\t\t\tstroke((199 * i + 10) % 255, (35 * i + 10) % 255, (240 * i + 10) % 255, 100);\n\t\t\t\tline(points_array[i].x, points_array[i].y, points_array[i+1].x/3, points_array[i+1].y/3);\n\t\t\t\ttranslate(width / 2, height / 2);\n\t\t\t\trotate(PI / 7);\n\t\t\t\ttranslate(-width / 2, -height / 2);\n\t\t\t}}\n\t\t\tpopMatrix();\n\t\t}\n\t}\n\t\n\tclass Trapezoid {\n\t\tPVector p1;\n\t\tPVector p2;\n\t\tPVector p3;\n\t\tPVector p4;\n\n\t\tTrapezoid(int px1, int py1, int px2, int py2, int px3, int py3, int px4, int py4) {\n\t\t\tp1 = new PVector(px1, py1);\n\t\t\tp2 = new PVector(px2, py2);\n\t\t\tp3 = new PVector(px3, py3);\n\t\t\tp4 = new PVector(px4, py4);\n\t\t}\n\t\tvoid show_dots(int c1, int c2, int c3, int a) {\n\t\t\tcolor fill1 = color(c1, c2, c3, a);\n\t\t\tfill(fill1);\n\t\t\tnoStroke();\n\t\t\tellipse(p1.x, p1.y, 10, 10);\n\t\t\tellipse(p2.x, p2.y, 10, 10);\n\t\t\tellipse(p3.x, p3.y, 10, 10);\n\t\t\tellipse(p4.x, p4.y, 10, 10);\n\t\t}\n\t\tvoid show_lines(int c1, int c2, int c3, int a) {\n\t\t\tcolor fill1 = color(c1, c2, c3, a);\n\t\t\tnoFill();\n\t\t\tstrokeWeight(width * 0.0015);\n\t\t\tstroke(fill1);\n\t\t\tline(p1.x, p1.y, p2.x, p2.y);\n\t\t\tline(p2.x, p2.y, p3.x, p3.y);\n\t\t\tline(p3.x, p3.y, p4.x, p4.y);\n\t\t\tline(p4.x, p4.y, p1.x, p1.y);\n\t\t\tline(p1.x, p1.y, p3.x, p3.y);\n\t\t\tline(p4.x, p4.y, p2.x, p2.y);\n\t\t}\n\t\tvoid show_shapes(int c1, int c2, int c3, int a) {\n\t\t\tcolor fill1 = color(c1, c2, c3, a);\n\t\t\tcolor fill2 = color(c1, c2, c1, c2);\n\t\t\tfill(fill1);\n\t\t\tnoStroke();\n\t\t\ttriangle(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);\n\t\t\tfill(fill2);\n\t\t\tnoStroke();\n\t\t\ttriangle(p4.x, p4.y, p2.x, p2.y, p3.x, p3.y);\n\t\t}\n\t}\n\tclass Rectangle {\n\t\tint rect_height;\n\t\tint rect_width;\n\t\tint corner_round;\n\t\tRectangle(int _rect_width, int _rect_height, int _corner_round) {\n\t\t\trect_height = _rect_height;\n\t\t\trect_width = _rect_width;\n\t\t\tcorner_round = _corner_round;\n\t\t}\n\t\tvoid show1(int c1, int c2, int c3, int a) {\n\t\t\tcolor fill1 = color(c1, c2, c3, a);\n\t\t\tfill(fill1);\n\t\t\tnoStroke();\n\t\t\trectMode(CENTER);\n\t\t\trect(width / 2, height / 2, rect_width, rect_height, corner_round);\n\t\t}\n\t\tvoid show3(int c1, int c2, int c3, int a) {\n\t\t\tcolor fill1 = color(c1, c2, c3, a);\n\t\t\tfill(fill1);\n\t\t\tnoStroke();\n\t\t\trectMode(CENTER);\n\t\t\tif (rect_height > rect_width) {\n\t\t\t\trect((width / 2) + (width * 0.2), height / 2, rect_width, rect_height, corner_round);\n\t\t\t\trect(width / 2, height / 2, rect_width, rect_height, corner_round);\n\t\t\t\trect((width / 2) - (width * 0.2), height / 2, rect_width, rect_height, corner_round);\n\t\t\t} else {\n\t\t\t\trect(width / 2, (height / 2) + (height * 0.2), rect_width, rect_height, corner_round);\n\t\t\t\trect(width / 2, height / 2, rect_width, rect_height, corner_round);\n\t\t\t\trect(width / 2, (height / 2) - (height * 0.2), rect_width, rect_height, corner_round);\n\t\t\t}\n\t\t}\n\t\tvoid show5(int c1, int c2, int c3, int a) {\n\t\t\tcolor fill1 = color(c1, c2, c3, a);\n\t\t\tfill(fill1);\n\t\t\tnoStroke();\n\t\t\trectMode(CENTER);\n\t\t\tif (rect_height > rect_width) {\n\t\t\t\trect((width / 2) + (width * 0.2), height / 2, rect_width, rect_height, corner_round);\n\t\t\t\trect((width / 2) + (width * 0.1), height / 2, rect_width, rect_height, corner_round);\n\t\t\t\trect(width / 2, height / 2, rect_width, rect_height, corner_round);\n\t\t\t\trect((width / 2) - (width * 0.1), height / 2, rect_width, rect_height, corner_round);\n\t\t\t\trect((width / 2) - (width * 0.2), height / 2, rect_width, rect_height, corner_round);\n\t\t\t} else {\n\t\t\t\trect(width / 2, (height / 2) + (height * 0.2), rect_width, rect_height, corner_round);\n\t\t\t\trect(width / 2, (height / 2) + (height * 0.1), rect_width, rect_height, corner_round);\n\t\t\t\trect(width / 2, height / 2, rect_width, rect_height, corner_round);\n\t\t\t\trect(width / 2, (height / 2) - (height * 0.1), rect_width, rect_height, corner_round);\n\t\t\t\trect(width / 2, (height / 2) - (height * 0.2), rect_width, rect_height, corner_round);\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Grid {\n\t\tint vertical_divider;\n\t\tint horizontal_divider;\n\t\tcolor grid_color = color(100, 100, 100, 300);\n\n\t\tGrid(int p, int q) {\n\t\t\tif (p < 4) {\n\t\t\t\tp = 4;\n\t\t\t}\n\t\t\tif (q < 4) {\n\t\t\t\tq = 4;\n\t\t\t}\n\t\t\tvertical_divider = p * 2;\n\t\t\thorizontal_divider = q * 2;\n\t\t}\n\n\t\tvoid show_diagonal(int mixer1) {\n\t\t\tnoFill();\n\t\t\tstrokeWeight(1);\n\t\t\tstroke(grid_color);\n\t\t\tmixer = mixer1 * 2;\n\t\t\tfor (int i = 0 - (vertical_divider * 2); i < width + (vertical_divider * 2); i++) {\n\t\t\t\tif ((i % vertical_divider) == 0) {\n\t\t\t\t\tline(i - mixer1, 0, i + mixer1, height);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid show_vertical() {\n\t\t\tnoFill();\n\t\t\tstrokeWeight(1);\n\t\t\tstroke(grid_color);\n\t\t\tPVector start = new PVector(0, 0);\n\t\t\tPVector end = new PVector(width, 0);\n\t\t\tPVector result = new PVector(0, 0);\n\t\t\tfor (int i = 0; i < vertical_divider; i++) {\n\t\t\t\tresult = new PVector(start.x + (i / vertical_divider) * (end.x - start.x), start.y + (i / vertical_divider) * (end.y - start.y))\n\t\t\t\tline(result.x, 0, result.x, height);\n\t\t\t}\n\t\t\tline(width - 1, 0, width - 1, height);\n\t\t}\n\n\t\tvoid show_horizontal() {\n\t\t\tnoFill();\n\t\t\tstrokeWeight(1);\n\t\t\tstroke(grid_color);\n\t\t\tPVector start = new PVector(0, 0);\n\t\t\tPVector end = new PVector(0, height);\n\t\t\tPVector result = new PVector(0, 0);\n\t\t\tfor (int i = 0; i < horizontal_divider; i++) {\n\t\t\t\tresult = new PVector(start.x + (i / horizontal_divider) * (end.x - start.x), start.y + (i / horizontal_divider) * (end.y - start.y))\n\t\t\t\tline(0, result.y, width, result.y);\n\t\t\t}\n\t\t\tline(0, height - 1, width, height - 1);\n\t\t}\n\t}","scriptJson":"{\"type\":\"processing\",\"version\":\"1.1.9\",\"aspectRatio\":\"4/3\",\"interactive\":\"false\",\"curation_status\":\"curated\"}"}]}}